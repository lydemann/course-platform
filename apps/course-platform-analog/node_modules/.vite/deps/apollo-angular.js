import {
  ApolloClient,
  NetworkStatus
} from "./chunk-KCCEFI4P.js";
import {
  gql
} from "./chunk-OHUEL7VO.js";
import "./chunk-OVSCSE5Z.js";
import "./chunk-3423CQWA.js";
import "./chunk-TGFQWSPX.js";
import "./chunk-UQUVBWRD.js";
import {
  Inject,
  Injectable,
  InjectionToken,
  NgModule,
  NgZone,
  Optional,
  setClassMetadata,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵinject
} from "./chunk-F5W7JMMH.js";
import "./chunk-6AXJVIE6.js";
import {
  queueScheduler
} from "./chunk-K7BLW2FG.js";
import {
  Observable,
  from,
  map,
  observable,
  observeOn,
  startWith
} from "./chunk-OIFAVY64.js";
import "./chunk-6QIBDZUR.js";
import {
  __publicField
} from "./chunk-WGAPYIUP.js";

// node_modules/.pnpm/apollo-angular@5.0.2_@angular+core@18.0.1_rxjs@7.8.1_zone.js@0.14.3__@apollo+client@3.9.4_gra_fh5mczerkpznsejcpcafgws2p4/node_modules/apollo-angular/fesm2022/ngApollo.mjs
function fromPromise(promiseFn) {
  return new Observable((subscriber) => {
    promiseFn().then((result) => {
      if (!subscriber.closed) {
        subscriber.next(result);
        subscriber.complete();
      }
    }, (error) => {
      if (!subscriber.closed) {
        subscriber.error(error);
      }
    });
    return () => subscriber.unsubscribe();
  });
}
function useMutationLoading(source, enabled) {
  if (!enabled) {
    return source.pipe(map((result) => ({
      ...result,
      loading: false
    })));
  }
  return source.pipe(startWith({
    loading: true
  }), map((result) => ({
    ...result,
    loading: !!result.loading
  })));
}
var ZoneScheduler = class {
  constructor(zone) {
    __publicField(this, "zone");
    __publicField(this, "now", Date.now ? Date.now : () => +/* @__PURE__ */ new Date());
    this.zone = zone;
  }
  schedule(work, delay = 0, state) {
    return this.zone.run(() => queueScheduler.schedule(work, delay, state));
  }
};
function fixObservable(obs) {
  obs[observable] = () => obs;
  return obs;
}
function wrapWithZone(obs, ngZone) {
  return obs.pipe(observeOn(new ZoneScheduler(ngZone)));
}
function pickFlag(flags, flag, defaultValue) {
  return flags && typeof flags[flag] !== "undefined" ? flags[flag] : defaultValue;
}
function useInitialLoading(obsQuery) {
  return function useInitialLoadingOperator(source) {
    return new Observable(function useInitialLoadingSubscription(subscriber) {
      const currentResult = obsQuery.getCurrentResult();
      const {
        loading,
        errors,
        error,
        partial,
        data
      } = currentResult;
      const {
        partialRefetch,
        fetchPolicy
      } = obsQuery.options;
      const hasError = errors || error;
      if (partialRefetch && partial && (!data || Object.keys(data).length === 0) && fetchPolicy !== "cache-only" && !loading && !hasError) {
        subscriber.next({
          ...currentResult,
          loading: true,
          networkStatus: NetworkStatus.loading
        });
      }
      return source.subscribe(subscriber);
    });
  };
}
var QueryRef = class {
  constructor(obsQuery, ngZone, options) {
    __publicField(this, "obsQuery");
    __publicField(this, "valueChanges");
    __publicField(this, "queryId");
    this.obsQuery = obsQuery;
    const wrapped = wrapWithZone(from(fixObservable(this.obsQuery)), ngZone);
    this.valueChanges = options.useInitialLoading ? wrapped.pipe(useInitialLoading(this.obsQuery)) : wrapped;
    this.queryId = this.obsQuery.queryId;
  }
  // ObservableQuery's methods
  get options() {
    return this.obsQuery.options;
  }
  get variables() {
    return this.obsQuery.variables;
  }
  result() {
    return this.obsQuery.result();
  }
  getCurrentResult() {
    return this.obsQuery.getCurrentResult();
  }
  getLastResult() {
    return this.obsQuery.getLastResult();
  }
  getLastError() {
    return this.obsQuery.getLastError();
  }
  resetLastResults() {
    return this.obsQuery.resetLastResults();
  }
  refetch(variables) {
    return this.obsQuery.refetch(variables);
  }
  fetchMore(fetchMoreOptions) {
    return this.obsQuery.fetchMore(fetchMoreOptions);
  }
  subscribeToMore(options) {
    return this.obsQuery.subscribeToMore(options);
  }
  updateQuery(mapFn) {
    return this.obsQuery.updateQuery(mapFn);
  }
  stopPolling() {
    return this.obsQuery.stopPolling();
  }
  startPolling(pollInterval) {
    return this.obsQuery.startPolling(pollInterval);
  }
  setOptions(opts) {
    return this.obsQuery.setOptions(opts);
  }
  setVariables(variables) {
    return this.obsQuery.setVariables(variables);
  }
};
var APOLLO_FLAGS = new InjectionToken("APOLLO_FLAGS");
var APOLLO_OPTIONS = new InjectionToken("APOLLO_OPTIONS");
var APOLLO_NAMED_OPTIONS = new InjectionToken("APOLLO_NAMED_OPTIONS");
var ApolloBase = class {
  constructor(ngZone, flags, _client) {
    __publicField(this, "ngZone");
    __publicField(this, "flags");
    __publicField(this, "_client");
    __publicField(this, "useInitialLoading");
    __publicField(this, "useMutationLoading");
    this.ngZone = ngZone;
    this.flags = flags;
    this._client = _client;
    this.useInitialLoading = pickFlag(flags, "useInitialLoading", false);
    this.useMutationLoading = pickFlag(flags, "useMutationLoading", false);
  }
  watchQuery(options) {
    return new QueryRef(this.ensureClient().watchQuery({
      ...options
    }), this.ngZone, {
      useInitialLoading: this.useInitialLoading,
      ...options
    });
  }
  query(options) {
    return fromPromise(() => this.ensureClient().query({
      ...options
    }));
  }
  mutate(options) {
    return useMutationLoading(fromPromise(() => this.ensureClient().mutate({
      ...options
    })), options.useMutationLoading ?? this.useMutationLoading);
  }
  subscribe(options, extra) {
    const obs = from(fixObservable(this.ensureClient().subscribe({
      ...options
    })));
    return extra && extra.useZone !== true ? obs : wrapWithZone(obs, this.ngZone);
  }
  /**
   * Get an instance of ApolloClient
   * @deprecated use `apollo.client` instead
   */
  getClient() {
    return this.client;
  }
  /**
   * Set a new instance of ApolloClient
   * Remember to clean up the store before setting a new client.
   * @deprecated use `apollo.client = client` instead
   *
   * @param client ApolloClient instance
   */
  setClient(client) {
    this.client = client;
  }
  /**
   * Get an instance of ApolloClient
   */
  get client() {
    return this._client;
  }
  /**
   * Set a new instance of ApolloClient
   * Remember to clean up the store before setting a new client.
   *
   * @param client ApolloClient instance
   */
  set client(client) {
    if (this._client) {
      throw new Error("Client has been already defined");
    }
    this._client = client;
  }
  ensureClient() {
    this.checkInstance();
    return this._client;
  }
  checkInstance() {
    if (!this._client) {
      throw new Error("Client has not been defined yet");
    }
  }
};
var _Apollo = class _Apollo extends ApolloBase {
  constructor(_ngZone, apolloOptions, apolloNamedOptions, flags) {
    super(_ngZone, flags);
    __publicField(this, "_ngZone");
    __publicField(this, "map", /* @__PURE__ */ new Map());
    this._ngZone = _ngZone;
    if (apolloOptions) {
      this.createDefault(apolloOptions);
    }
    if (apolloNamedOptions && typeof apolloNamedOptions === "object") {
      for (let name in apolloNamedOptions) {
        if (apolloNamedOptions.hasOwnProperty(name)) {
          const options = apolloNamedOptions[name];
          this.create(options, name);
        }
      }
    }
  }
  /**
   * Create an instance of ApolloClient
   * @param options Options required to create ApolloClient
   * @param name client's name
   */
  create(options, name) {
    if (isDefault(name)) {
      this.createDefault(options);
    } else {
      this.createNamed(name, options);
    }
  }
  /**
   * Use a default ApolloClient
   */
  default() {
    return this;
  }
  /**
   * Use a named ApolloClient
   * @param name client's name
   */
  use(name) {
    if (isDefault(name)) {
      return this.default();
    }
    return this.map.get(name);
  }
  /**
   * Create a default ApolloClient, same as `apollo.create(options)`
   * @param options ApolloClient's options
   */
  createDefault(options) {
    if (this.getClient()) {
      throw new Error("Apollo has been already created.");
    }
    return this.setClient(new ApolloClient(options));
  }
  /**
   * Create a named ApolloClient, same as `apollo.create(options, name)`
   * @param name client's name
   * @param options ApolloClient's options
   */
  createNamed(name, options) {
    if (this.map.has(name)) {
      throw new Error(`Client ${name} has been already created`);
    }
    this.map.set(name, new ApolloBase(this._ngZone, this.flags, new ApolloClient(options)));
  }
  /**
   * Remember to clean up the store before removing a client
   * @param name client's name
   */
  removeClient(name) {
    if (isDefault(name)) {
      this._client = void 0;
    } else {
      this.map.delete(name);
    }
  }
};
__publicField(_Apollo, "ɵfac", function Apollo_Factory(t) {
  return new (t || _Apollo)(ɵɵinject(NgZone), ɵɵinject(APOLLO_OPTIONS, 8), ɵɵinject(APOLLO_NAMED_OPTIONS, 8), ɵɵinject(APOLLO_FLAGS, 8));
});
__publicField(_Apollo, "ɵprov", ɵɵdefineInjectable({
  token: _Apollo,
  factory: _Apollo.ɵfac
}));
var Apollo = _Apollo;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Apollo, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [APOLLO_OPTIONS]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [APOLLO_NAMED_OPTIONS]
      }, {
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [APOLLO_FLAGS]
      }, {
        type: Optional
      }]
    }];
  }, null);
})();
function isDefault(name) {
  return !name || name === "default";
}
var PROVIDERS = [Apollo];
var _ApolloModule = class _ApolloModule {
};
__publicField(_ApolloModule, "ɵfac", function ApolloModule_Factory(t) {
  return new (t || _ApolloModule)();
});
__publicField(_ApolloModule, "ɵmod", ɵɵdefineNgModule({
  type: _ApolloModule
}));
__publicField(_ApolloModule, "ɵinj", ɵɵdefineInjector({
  providers: PROVIDERS
}));
var ApolloModule = _ApolloModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApolloModule, [{
    type: NgModule,
    args: [{
      providers: PROVIDERS
    }]
  }], null, null);
})();
var _Query = class _Query {
  constructor(apollo) {
    __publicField(this, "apollo");
    __publicField(this, "document");
    __publicField(this, "client", "default");
    this.apollo = apollo;
  }
  watch(variables, options) {
    return this.apollo.use(this.client).watchQuery({
      ...options,
      variables,
      query: this.document
    });
  }
  fetch(variables, options) {
    return this.apollo.use(this.client).query({
      ...options,
      variables,
      query: this.document
    });
  }
};
__publicField(_Query, "ɵfac", function Query_Factory(t) {
  return new (t || _Query)(ɵɵinject(Apollo));
});
__publicField(_Query, "ɵprov", ɵɵdefineInjectable({
  token: _Query,
  factory: _Query.ɵfac
}));
var Query = _Query;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Query, [{
    type: Injectable
  }], function() {
    return [{
      type: Apollo
    }];
  }, null);
})();
var _Mutation = class _Mutation {
  constructor(apollo) {
    __publicField(this, "apollo");
    __publicField(this, "document");
    __publicField(this, "client", "default");
    this.apollo = apollo;
  }
  mutate(variables, options) {
    return this.apollo.use(this.client).mutate({
      ...options,
      variables,
      mutation: this.document
    });
  }
};
__publicField(_Mutation, "ɵfac", function Mutation_Factory(t) {
  return new (t || _Mutation)(ɵɵinject(Apollo));
});
__publicField(_Mutation, "ɵprov", ɵɵdefineInjectable({
  token: _Mutation,
  factory: _Mutation.ɵfac
}));
var Mutation = _Mutation;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Mutation, [{
    type: Injectable
  }], function() {
    return [{
      type: Apollo
    }];
  }, null);
})();
var _Subscription = class _Subscription {
  constructor(apollo) {
    __publicField(this, "apollo");
    __publicField(this, "document");
    __publicField(this, "client", "default");
    this.apollo = apollo;
  }
  subscribe(variables, options, extra) {
    return this.apollo.use(this.client).subscribe({
      ...options,
      variables,
      query: this.document
    }, extra);
  }
};
__publicField(_Subscription, "ɵfac", function Subscription_Factory(t) {
  return new (t || _Subscription)(ɵɵinject(Apollo));
});
__publicField(_Subscription, "ɵprov", ɵɵdefineInjectable({
  token: _Subscription,
  factory: _Subscription.ɵfac
}));
var Subscription = _Subscription;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Subscription, [{
    type: Injectable
  }], function() {
    return [{
      type: Apollo
    }];
  }, null);
})();
function typedGQLTag(literals, ...placeholders) {
  return gql(literals, ...placeholders);
}
var gql2 = typedGQLTag;
var graphql = typedGQLTag;
export {
  APOLLO_FLAGS,
  APOLLO_NAMED_OPTIONS,
  APOLLO_OPTIONS,
  Apollo,
  ApolloBase,
  ApolloModule,
  Mutation,
  Query,
  QueryRef,
  Subscription,
  gql2 as gql,
  graphql
};
//# sourceMappingURL=apollo-angular.js.map
